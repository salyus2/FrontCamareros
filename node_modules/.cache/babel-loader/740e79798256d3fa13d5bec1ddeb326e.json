{"ast":null,"code":"import axios from \"axios\";\nimport { login, register, postOrder } from \"./authService\";\n\nfunction isBearerTokenRequired(url) {\n  const parsedURL = new URL(url);\n\n  if ([\"/account/login\", \"/account\"].includes(parsedURL.pathname)) {\n    return false;\n  }\n\n  return true;\n} // Al iniciar este módulo recuperamos el usuario guardado del localStorage.\n// La idea es la misma que en el auth-context.js. Si el usuario refresca la página\n// mantengo el estado en el que estaba\n\n\nconst currentUser = JSON.parse(localStorage.getItem(\"currentUser\")); // Iniciamos la variable token con lo almacenado en el localStorage\n// Si no tenia nada la inicio a null\n// La siguiente condicion de OR si la primera parte es true entonces se queda con el\n// resultado de la primera condición y en caso contrario con la segunda (null)\n\nlet accessToken = currentUser && currentUser.accessToken || null; // Definimos interceptors de request y response\n// REQUEST\n// -------\n// En cada una de las peticiones se ejecutaran estas funciones\n// Si la cadena de interceptors no falla entonces se irá ejecutando la\n// primera función, si falla alguno de los interceptors entonces irá por la segunda.\n\naxios.interceptors.request.use(function (config) {\n  // Compruebo si tengo token y si necesito enviarlo en el\n  // header de Authorization\n  if (accessToken && isBearerTokenRequired(config.url)) {\n    console.log(accessToken, isBearerTokenRequired(config.url));\n    config.headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  } // Acordarnos de devolver la config!!. Si no no sigue la cadena\n  // y la petición no se hace\n\n\n  return config;\n}, function (error) {\n  // Siempre devolver el error de esta forma, a través de Promise.reject\n  return Promise.reject(error);\n}); // RESPONSE\n// --------\n// Cada vez que llegue una respuesta entonces se ejecutarán los interceptors\n// La primera función si la respuesta es correcta\n// La segunda si la respuesta trae un status >=400 o bien si tengo mas interceptors\n// y alguno produce un error\n\naxios.interceptors.response.use(function (response) {\n  // Si la respuesta trae un token entonces lo almaceno\n  // Mi aplicación supone que mi backend envia un objeto con { token, user } siempre\n  // que el usuario se identifica (Login, Registro)\n  // En otra aplicación podría ser diferente\n  if (response.data.accessToken) {\n    localStorage.setItem(\"currentUser\", JSON.stringify(response.data));\n    accessToken = response.data.accessToken;\n  }\n\n  return response;\n}, function (error) {\n  // En caso de que el token expire (401)\n  // y no sea el endpoint de login (que tambien devuelve 401 cuando las credenciales son invalidas)\n  // Entonces redirijo a la URL de login y limpio el localStorage\n  if (error.response.status === 401 && error.config.url.indexOf(\"/login\") === -1) {\n    localStorage.removeItem(\"currentUser\");\n    window.location.href = \"/login\";\n  } // Siempre devolver el error de esta forma, a través de Promise.reject\n\n\n  return Promise.reject(error);\n});\nexport { login, register, postOrder };","map":{"version":3,"sources":["/home/hab14/Nuva CArpeta/proyecto1/restaurant-proyect/src/http/index.js"],"names":["axios","login","register","postOrder","isBearerTokenRequired","url","parsedURL","URL","includes","pathname","currentUser","JSON","parse","localStorage","getItem","accessToken","interceptors","request","use","config","console","log","headers","error","Promise","reject","response","data","setItem","stringify","status","indexOf","removeItem","window","location","href"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,KAAT,EAAgBC,QAAhB,EAA0BC,SAA1B,QAA2C,eAA3C;;AAEA,SAASC,qBAAT,CAA+BC,GAA/B,EAAoC;AAChC,QAAMC,SAAS,GAAG,IAAIC,GAAJ,CAAQF,GAAR,CAAlB;;AACA,MAAI,CAAC,gBAAD,EAAmB,UAAnB,EAA+BG,QAA/B,CAAwCF,SAAS,CAACG,QAAlD,CAAJ,EAAiE;AAC7D,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH,C,CAED;AACA;AACA;;;AACA,MAAMC,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAWC,YAAY,CAACC,OAAb,CAAqB,aAArB,CAAX,CAApB,C,CAEA;AACA;AACA;AACA;;AACA,IAAIC,WAAW,GAAIL,WAAW,IAAIA,WAAW,CAACK,WAA5B,IAA4C,IAA9D,C,CAEA;AACA;AACA;AACA;AACA;AACA;;AACAf,KAAK,CAACgB,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CACI,UAAUC,MAAV,EAAkB;AACd;AACA;AACA,MAAIJ,WAAW,IAAIX,qBAAqB,CAACe,MAAM,CAACd,GAAR,CAAxC,EAAsD;AAClDe,IAAAA,OAAO,CAACC,GAAR,CAAYN,WAAZ,EAAyBX,qBAAqB,CAACe,MAAM,CAACd,GAAR,CAA9C;AACAc,IAAAA,MAAM,CAACG,OAAP,CAAe,eAAf,IAAmC,UAASP,WAAY,EAAxD;AACH,GANa,CAOd;AACA;;;AACA,SAAOI,MAAP;AACH,CAXL,EAYI,UAAUI,KAAV,EAAiB;AACb;AACA,SAAOC,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACH,CAfL,E,CAkBA;AACA;AACA;AACA;AACA;AACA;;AACAvB,KAAK,CAACgB,YAAN,CAAmBU,QAAnB,CAA4BR,GAA5B,CACI,UAAUQ,QAAV,EAAoB;AAChB;AACA;AACA;AACA;AACA,MAAIA,QAAQ,CAACC,IAAT,CAAcZ,WAAlB,EAA+B;AAC3BF,IAAAA,YAAY,CAACe,OAAb,CAAqB,aAArB,EAAoCjB,IAAI,CAACkB,SAAL,CAAeH,QAAQ,CAACC,IAAxB,CAApC;AACAZ,IAAAA,WAAW,GAAGW,QAAQ,CAACC,IAAT,CAAcZ,WAA5B;AACH;;AACD,SAAOW,QAAP;AACH,CAXL,EAYI,UAAUH,KAAV,EAAiB;AACb;AACA;AACA;AACA,MACIA,KAAK,CAACG,QAAN,CAAeI,MAAf,KAA0B,GAA1B,IACAP,KAAK,CAACJ,MAAN,CAAad,GAAb,CAAiB0B,OAAjB,CAAyB,QAAzB,MAAuC,CAAC,CAF5C,EAGE;AACElB,IAAAA,YAAY,CAACmB,UAAb,CAAwB,aAAxB;AACAC,IAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,QAAvB;AACH,GAVY,CAWb;;;AACA,SAAOX,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACH,CAzBL;AA4BA,SAAStB,KAAT,EAAgBC,QAAhB,EAA0BC,SAA1B","sourcesContent":["import axios from \"axios\";\nimport { login, register, postOrder } from \"./authService\";\n\nfunction isBearerTokenRequired(url) {\n    const parsedURL = new URL(url);\n    if ([\"/account/login\", \"/account\"].includes(parsedURL.pathname)) {\n        return false;\n    }\n    return true;\n}\n\n// Al iniciar este módulo recuperamos el usuario guardado del localStorage.\n// La idea es la misma que en el auth-context.js. Si el usuario refresca la página\n// mantengo el estado en el que estaba\nconst currentUser = JSON.parse(localStorage.getItem(\"currentUser\"));\n\n// Iniciamos la variable token con lo almacenado en el localStorage\n// Si no tenia nada la inicio a null\n// La siguiente condicion de OR si la primera parte es true entonces se queda con el\n// resultado de la primera condición y en caso contrario con la segunda (null)\nlet accessToken = (currentUser && currentUser.accessToken) || null;\n\n// Definimos interceptors de request y response\n// REQUEST\n// -------\n// En cada una de las peticiones se ejecutaran estas funciones\n// Si la cadena de interceptors no falla entonces se irá ejecutando la\n// primera función, si falla alguno de los interceptors entonces irá por la segunda.\naxios.interceptors.request.use(\n    function (config) {\n        // Compruebo si tengo token y si necesito enviarlo en el\n        // header de Authorization\n        if (accessToken && isBearerTokenRequired(config.url)) {\n            console.log(accessToken, isBearerTokenRequired(config.url))\n            config.headers[\"Authorization\"] = `Bearer ${accessToken}`;\n        }\n        // Acordarnos de devolver la config!!. Si no no sigue la cadena\n        // y la petición no se hace\n        return config;\n    },\n    function (error) {\n        // Siempre devolver el error de esta forma, a través de Promise.reject\n        return Promise.reject(error);\n    }\n);\n\n// RESPONSE\n// --------\n// Cada vez que llegue una respuesta entonces se ejecutarán los interceptors\n// La primera función si la respuesta es correcta\n// La segunda si la respuesta trae un status >=400 o bien si tengo mas interceptors\n// y alguno produce un error\naxios.interceptors.response.use(\n    function (response) {\n        // Si la respuesta trae un token entonces lo almaceno\n        // Mi aplicación supone que mi backend envia un objeto con { token, user } siempre\n        // que el usuario se identifica (Login, Registro)\n        // En otra aplicación podría ser diferente\n        if (response.data.accessToken) {\n            localStorage.setItem(\"currentUser\", JSON.stringify(response.data));\n            accessToken = response.data.accessToken;\n        }\n        return response;\n    },\n    function (error) {\n        // En caso de que el token expire (401)\n        // y no sea el endpoint de login (que tambien devuelve 401 cuando las credenciales son invalidas)\n        // Entonces redirijo a la URL de login y limpio el localStorage\n        if (\n            error.response.status === 401 &&\n            error.config.url.indexOf(\"/login\") === -1\n        ) {\n            localStorage.removeItem(\"currentUser\");\n            window.location.href = \"/login\";\n        }\n        // Siempre devolver el error de esta forma, a través de Promise.reject\n        return Promise.reject(error);\n    }\n);\n\nexport { login, register, postOrder };\n"]},"metadata":{},"sourceType":"module"}