{"ast":null,"code":"import axios from \"axios\";\nimport { login, register } from \"./authService\";\n\nfunction isBearerTokenRequired(url) {\n  const parsedURL = new URL(url);\n\n  if ([\"/account/login\", \"/account\"].includes(parsedURL.pathname)) {\n    return false;\n  }\n\n  return true;\n} // Al iniciar este módulo recuperamos el usuario guardado del localStorage.\n// La idea es la misma que en el auth-context.js. Si el usuario refresca la página\n// mantengo el estado en el que estaba\n\n\nconst currentUser = JSON.parse(localStorage.getItem(\"currentUser\")); // Iniciamos la variable token con lo almacenado en el localStorage\n// Si no tenia nada la inicio a null\n// La siguiente condicion de OR si la primera parte es true entonces se queda con el\n// resultado de la primera condición y en caso contrario con la segunda (null)\n\nlet token = currentUser && currentUser.accessToken || null; // Definimos interceptors de request y response\n// REQUEST\n// -------\n// En cada una de las peticiones se ejecutaran estas funciones\n// Si la cadena de interceptors no falla entonces se irá ejecutando la\n// primera función, si falla alguno de los interceptors entonces irá por la segunda.\n\naxios.interceptors.request.use(function (config) {\n  // Compruebo si tengo token y si necesito enviarlo en el\n  // header de Authorization\n  if (token && isBearerTokenRequired(config.url)) {\n    config.headers[\"Authorization\"] = \"Bearer \".concat(token);\n  } // Acordarnos de devolver la config!!. Si no no sigue la cadena\n  // y la petición no se hace\n\n\n  return config;\n}, function (error) {\n  // Siempre devolver el error de esta forma, a través de Promise.reject\n  return Promise.reject(error);\n}); // RESPONSE\n// --------\n// Cada vez que llegue una respuesta entonces se ejecutarán los interceptors\n// La primera función si la respuesta es correcta\n// La segunda si la respuesta trae un status >=400 o bien si tengo mas interceptors\n// y alguno produce un error\n\naxios.interceptors.response.use(function (response) {\n  // Si la respuesta trae un token entonces lo almaceno\n  // Mi aplicación supone que mi backend envia un objeto con { token, user } siempre\n  // que el usuario se identifica (Login, Registro)\n  // En otra aplicación podría ser diferente\n  if (response.data.accessToken) {\n    localStorage.setItem(\"currentUser\", JSON.stringify(response.data));\n    token = response.data.token;\n  }\n\n  return response;\n}, function (error) {\n  // En caso de que el token expire (401)\n  // y no sea el endpoint de login (que tambien devuelve 401 cuando las credenciales son invalidas)\n  // Entonces redirijo a la URL de login y limpio el localStorage\n  if (error.response.status === 401 && error.config.url.indexOf(\"/login\") === -1) {\n    localStorage.removeItem(\"currentUser\");\n    window.location.href = \"/login\";\n  } // Siempre devolver el error de esta forma, a través de Promise.reject\n\n\n  return Promise.reject(error);\n});\nexport { login, register };","map":{"version":3,"sources":["/home/hab14/Nuva CArpeta/proyecto1/restaurant-proyect/src/http/index.js"],"names":["axios","login","register","isBearerTokenRequired","url","parsedURL","URL","includes","pathname","currentUser","JSON","parse","localStorage","getItem","token","accessToken","interceptors","request","use","config","headers","error","Promise","reject","response","data","setItem","stringify","status","indexOf","removeItem","window","location","href"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,KAAT,EAAgBC,QAAhB,QAAgC,eAAhC;;AAEA,SAASC,qBAAT,CAA+BC,GAA/B,EAAoC;AAChC,QAAMC,SAAS,GAAG,IAAIC,GAAJ,CAAQF,GAAR,CAAlB;;AACA,MAAI,CAAC,gBAAD,EAAmB,UAAnB,EAA+BG,QAA/B,CAAwCF,SAAS,CAACG,QAAlD,CAAJ,EAAiE;AAC7D,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH,C,CAED;AACA;AACA;;;AACA,MAAMC,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAWC,YAAY,CAACC,OAAb,CAAqB,aAArB,CAAX,CAApB,C,CAEA;AACA;AACA;AACA;;AACA,IAAIC,KAAK,GAAIL,WAAW,IAAIA,WAAW,CAACM,WAA5B,IAA4C,IAAxD,C,CAEA;AACA;AACA;AACA;AACA;AACA;;AACAf,KAAK,CAACgB,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CACI,UAAUC,MAAV,EAAkB;AACd;AACA;AACA,MAAIL,KAAK,IAAIX,qBAAqB,CAACgB,MAAM,CAACf,GAAR,CAAlC,EAAgD;AAC5Ce,IAAAA,MAAM,CAACC,OAAP,CAAe,eAAf,qBAA4CN,KAA5C;AACH,GALa,CAMd;AACA;;;AACA,SAAOK,MAAP;AACH,CAVL,EAWI,UAAUE,KAAV,EAAiB;AACb;AACA,SAAOC,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACH,CAdL,E,CAiBA;AACA;AACA;AACA;AACA;AACA;;AACArB,KAAK,CAACgB,YAAN,CAAmBQ,QAAnB,CAA4BN,GAA5B,CACI,UAAUM,QAAV,EAAoB;AAChB;AACA;AACA;AACA;AACA,MAAIA,QAAQ,CAACC,IAAT,CAAcV,WAAlB,EAA+B;AAC3BH,IAAAA,YAAY,CAACc,OAAb,CAAqB,aAArB,EAAoChB,IAAI,CAACiB,SAAL,CAAeH,QAAQ,CAACC,IAAxB,CAApC;AACAX,IAAAA,KAAK,GAAGU,QAAQ,CAACC,IAAT,CAAcX,KAAtB;AACH;;AACD,SAAOU,QAAP;AACH,CAXL,EAYI,UAAUH,KAAV,EAAiB;AACb;AACA;AACA;AACA,MACIA,KAAK,CAACG,QAAN,CAAeI,MAAf,KAA0B,GAA1B,IACAP,KAAK,CAACF,MAAN,CAAaf,GAAb,CAAiByB,OAAjB,CAAyB,QAAzB,MAAuC,CAAC,CAF5C,EAGE;AACEjB,IAAAA,YAAY,CAACkB,UAAb,CAAwB,aAAxB;AACAC,IAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,QAAvB;AACH,GAVY,CAWb;;;AACA,SAAOX,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACH,CAzBL;AA4BA,SAASpB,KAAT,EAAgBC,QAAhB","sourcesContent":["import axios from \"axios\";\nimport { login, register } from \"./authService\";\n\nfunction isBearerTokenRequired(url) {\n    const parsedURL = new URL(url);\n    if ([\"/account/login\", \"/account\"].includes(parsedURL.pathname)) {\n        return false;\n    }\n    return true;\n}\n\n// Al iniciar este módulo recuperamos el usuario guardado del localStorage.\n// La idea es la misma que en el auth-context.js. Si el usuario refresca la página\n// mantengo el estado en el que estaba\nconst currentUser = JSON.parse(localStorage.getItem(\"currentUser\"));\n\n// Iniciamos la variable token con lo almacenado en el localStorage\n// Si no tenia nada la inicio a null\n// La siguiente condicion de OR si la primera parte es true entonces se queda con el\n// resultado de la primera condición y en caso contrario con la segunda (null)\nlet token = (currentUser && currentUser.accessToken) || null;\n\n// Definimos interceptors de request y response\n// REQUEST\n// -------\n// En cada una de las peticiones se ejecutaran estas funciones\n// Si la cadena de interceptors no falla entonces se irá ejecutando la\n// primera función, si falla alguno de los interceptors entonces irá por la segunda.\naxios.interceptors.request.use(\n    function (config) {\n        // Compruebo si tengo token y si necesito enviarlo en el\n        // header de Authorization\n        if (token && isBearerTokenRequired(config.url)) {\n            config.headers[\"Authorization\"] = `Bearer ${token}`;\n        }\n        // Acordarnos de devolver la config!!. Si no no sigue la cadena\n        // y la petición no se hace\n        return config;\n    },\n    function (error) {\n        // Siempre devolver el error de esta forma, a través de Promise.reject\n        return Promise.reject(error);\n    }\n);\n\n// RESPONSE\n// --------\n// Cada vez que llegue una respuesta entonces se ejecutarán los interceptors\n// La primera función si la respuesta es correcta\n// La segunda si la respuesta trae un status >=400 o bien si tengo mas interceptors\n// y alguno produce un error\naxios.interceptors.response.use(\n    function (response) {\n        // Si la respuesta trae un token entonces lo almaceno\n        // Mi aplicación supone que mi backend envia un objeto con { token, user } siempre\n        // que el usuario se identifica (Login, Registro)\n        // En otra aplicación podría ser diferente\n        if (response.data.accessToken) {\n            localStorage.setItem(\"currentUser\", JSON.stringify(response.data));\n            token = response.data.token;\n        }\n        return response;\n    },\n    function (error) {\n        // En caso de que el token expire (401)\n        // y no sea el endpoint de login (que tambien devuelve 401 cuando las credenciales son invalidas)\n        // Entonces redirijo a la URL de login y limpio el localStorage\n        if (\n            error.response.status === 401 &&\n            error.config.url.indexOf(\"/login\") === -1\n        ) {\n            localStorage.removeItem(\"currentUser\");\n            window.location.href = \"/login\";\n        }\n        // Siempre devolver el error de esta forma, a través de Promise.reject\n        return Promise.reject(error);\n    }\n);\n\nexport { login, register };\n"]},"metadata":{},"sourceType":"module"}